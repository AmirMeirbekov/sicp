# [Глава 1](../index.md#Глава-1-Построение-абстракций-с-помощью-процедур)

### Упражнение 1.20
Процесс, порождаемый процедурой, разумеется, зависит от того, по каким правилам работает интерпретатор. В качестве примера рассмотрим итеративную процедуру gcd:
```clojure
(defn gcd [a b]
  (cond
    (zero? b) a
    :else (gcd b
               (rem a
                    b)))))
```
Предположим, что мы вычисляем эту процедуру с помощью нормального порядка, описанного в разделе 1.1.5. (Правило нормального порядка вычислений для if описано в [упражнении 1.5](./ex_1_05.md)) Используя подстановочную модель для нормального порядка, проиллюстрируйте процесс, порождаемый при вычислении `(gcd 206 40)` и укажите, какие операции вычисления остатка действительно выполняются. Сколько операций `remainder` выполняется на самом деле при вычислении `(gcd 206 40)` в нормальном порядке? При вычислении в аппликативном порядке?

#### Решение
- Сколько операций `remainder` выполняется на самом деле при вычислении `(gcd 206 40)` в нормальном порядке? `18`
- При вычислении в аппликативном порядке? `4`

[Code](../../src/sicp/chapter01/1_20.clj) | [Test](../../test/sicp/chapter01/1_20_test.clj)
