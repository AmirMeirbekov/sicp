# [Глава 2](../index.md#Глава-2-Построение-абстракций-с-помощью-данных)

### Упражнение 2.19
Рассмотрим программу подсчета способов размена из раздела 1.2.2. Было бы приятно иметь возможность легко изменять валюту, которую эта программа использует, так, чтобы можно было, например, вычислить, сколькими способами можно разменять британский фунт. Эта программа написана так, что знание о валюте распределено между процедурами first-denomination и count-change (которая знает, что существует пять видов американских монет). Приятнее было бы иметь возможность просто задавать список монет, которые можно использовать при размене. Мы хотим переписать процедуру `cc` так, чтобы ее вторым аргументом был список монет, а не целое число, которое указывает, какие монеты использовать. Тогда у нас могли бы быть списки, определяющие типы валют:

```clojure
(defn us-coins (list 50 25 10 5 1))
(defn uk-coins (list 100 50 20 10 5 2 1 0.5))
```

Можно было бы вызывать `cc` следующим образом:

```clojure
(cc 100 us-coins)
;=> 292
```

Это потребует некоторых изменений в программе `cc`. Ее форма останется прежней, но со вторым аргументом она будет работать иначе, вот так:

```clojure
(defn cc
  [amount coin-values]
  (cond (zero? amount) 1
        (or (neg? amount)
            (no-more? coin-values)) 0
        :else (+ (cc amount
                     (except-first-denomination coin-values))
                 (cc (- amount
                        (first-denomination coin-values))
                     coin-values))))
```

Определите процедуры `first-denomination`, `except-first-denomination` и `no-more?` в терминах элементарных операций над списковыми структурами. Влияет ли порядок списка `coin-values` на результат, получаемый `cc`? Почему?

#### Решение
Порядок списка `coin-values` не влияет на результат процедуры `cc`, так как алгоритм `cc` независит от упорядоченности списка `coin-values`.

[Code](../../src/sicp/chapter02/2_19.clj) | [Test](../../test/sicp/chapter02/2_19_test.clj)
