# [Глава 2](../index.md#Глава-2-Построение-абстракций-с-помощью-данных)

### Упражнение 2.37
Предположим, что мы представляем векторы `v = (vᵢ)` как последовательности чисел, а матрицы `m = (mᵢⱼ)` как последовательности векторов (рядов матрицы). Например, матрица:

```
[ 1 2 3 4 ]
[ 4 5 6 6 ]
[ 6 7 8 9 ]
```

представляется в виде последовательности `((1 2 3 4) (4 5 6 6) (6 7 8 9))`. Имея такое представление, мы можем использовать операции над последовательностями, чтобы кратко выразить основные действия над матрицами и векторами. Эти операции (описанные в любой книге по матричной алгебре) следующие:

**Скалярное произведение** `(dot-product v w)` возвращает сумму `Σᵢvᵢwᵢ`

**Произведение матрицы и вектора** `(matrix-*-vector m v)` возвращает вектор `t`, где `tᵢ = Σⱼmᵢⱼvᵢ`

**Произведение матриц** `(matrix-*-matrix m n)` возвращает марицу p, где `pᵢⱼ = Σₖmᵢₖnₖⱼ`

**Транспозиция** `(transpose m)` возвращает матрицу n, где `nᵢⱼ = mᵢⱼ`

Скалярное произведение мы можем определить так:

```clojure
(defn dot-product
  [v w]
  (reduce + (map * v w)))
```

Заполните пропуски в следующих процедурах для вычисления остальных матричных операций. (Процедура `accumulate-n` описана в [упражнении 2.36](./ex_2_36.md))

```clojure
(defn matrix-*-vector
  [m v]
  (map <??> m))
```

```clojure
(defn transpose
  [m]
  (<??> map <??> m))
```

```clojure
(defn matrix-*-matrix
  [m n]
  (let [cols (transpose n)]
    (map <??> m)))
```

#### Решение
[Code](../../src/sicp/chapter02/2_37.clj) | [Test](../../test/sicp/chapter02/2_37_test.clj)
