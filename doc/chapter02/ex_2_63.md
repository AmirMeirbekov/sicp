# [Глава 2](../index.md#Глава-2)

### Упражнение 2.63
Каждая из следующих двух процедур преобразует дерево в список:

```clojure
(defn tree->list-1
  [tree]
  (if (empty? tree)
    '()
    (concat (tree->list-1 (left-branch tree))
            (cons (entry tree)
                  (tree->list-1 (right-branch tree))))))

(defn tree->list-2
  [tree]
  (letfn [(copy-to-list [tree result-list]
            (if (empty? tree)
              result-list
              (copy-to-list (left-branch tree)
                            (cons (entry tree)
                                  (copy-to-list (right-branch tree)
                                                result-list)))))]
    (copy-to-list tree '())))
```

- Для всякого ли дерева эти процедуры дают одинаковый результат? Если нет, то как их результаты различаются? Какой результат дают эти две процедуры для деревьев с рисунка 2.16?
- Одинаков ли порядок роста этих процедур по отношению к числу шагов, требуемых для преобразования сбалансированного дерева с `n` элементами в список? Если нет, которая из них растет медленнее?

#### Решение
Обе процедуры всегда дают одинаковый результат (см. тесты).
Порядок роста процедуры `tree->list-1` - Θ(n²), из за использования процедуры `concat` c Θ(n) для каждого узла дерева.
Порядок роста процедуры `tree->list-2` - Θ(n), так как она выполняет над каждым узлом дерева только константные (Θ(1)) операции.

[Code](../../src/sicp/chapter02/2_63.clj) | [Test](../../test/sicp/chapter02/2_63_test.clj)

