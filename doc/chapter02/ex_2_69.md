# [Глава 2](../index.md#Глава-2-Построение-абстракций-с-помощью-данных)

### Упражнение 2.69
Следующая процедура берет в качестве аргумента список пар вида символ-частота (где ни один символ не встречается более, чем в одной паре) и порождает дерево кодирования по Хаффману в соответствии с алгоритмом Хаффмана.

```clojure
(defn generate-huffman-tree
  [pairs]
  (successive-merge (make-leaf-set pairs)))
```

Приведенная выше процедура `make-leaf-set` преобразует список пар в упорядоченное множество пар. Вам нужно написать процедуру `successive-merge`, которая при помощи `make-code-tree` сливает наиболее легкие элементы множества, пока не останется только один элемент, который и представляет собой требуемое дерево Хаффмана. (Эта процедура устроена немного хитро, но она не такая уж сложная. Если Вы видите, что строите сложную процедуру, значит, почти наверняка Вы делаете что-то не то. Можно извлечь немалое преимущество из того, что мы используем упорядоченное представление для множеств.)

#### Решение
[Code](../../src/sicp/chapter02/2_69.clj) | [Test](../../test/sicp/chapter02/2_69_test.clj)

